---
title: "scMaSigPro: Workflow"
subtitle: "Quick Start Guide"
author: "Priyansh Srivastava"
package: "scMaSigPro"
abstract: |
  `scMaSigPro` is a Bioconductor package designed for the analysis of single-cell RNA-seq data along pseudotime. 
  It builds upon the `maSigPro` package to identify genes with significant expression changes across different 
  branching paths in a pseudotime-ordered single-cell dataset. This vignette illustrates the basic workflow 
  of `scMaSigPro`, providing a step-by-step guide for users.
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{scMaSigPro Basic Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(scMaSigPro)
```

## Introduction
`scMaSigPro` is a polynomial regression-based approach inspired by the maSigPro
package tailored for single-cell RNA-seq data. It discretizes cell expression
along pseudotime while preserving cellular order, then applies the maSigPro model
to pinpoint genes exhibiting significant expression profile differences among
branching paths.

## Installation
Currently, `scMaSigPro` is available on GitHub and can be installed as follows:

```{r, echo=TRUE, eval=FALSE}
# Use public PAT
publicPat <- "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"

# Install devtools if not already installed
if (!requireNamespace("devtools", quietly = TRUE)) {
  install.packages("devtools")
}

# Install scMaSigPro
devtools::install_github("spriyansh/scMaSigPro",
  ref = "dev",
  auth_token = publicPat,
  build_vignettes = TRUE,
  build_manual = TRUE,
  upgrade = "never",
  force = TRUE,
  quiet = TRUE,
)
```

## Basic Workflow
Here, we demonstrate the basic workflow of `scMaSigPro` using a simulated dataset
included in the package.

### Set Seed for Reproducibility
```{r, eval=TRUE, echo=TRUE}
set.seed(123)
```

## Step 1: Load the `scMaSigPro` package and the dataset
```{r, eval=TRUE, echo=TRUE}
# Load Package
library(scMaSigPro)
suppressPackageStartupMessages(library(ggplot2)) # (Optional Import)
suppressPackageStartupMessages(library(SingleCellExperiment)) # (Optional Import)

# Load example data
data("splat.sim", package = "scMaSigPro")
```

### Step 1.1: Plot the data
```{r, eval=TRUE, echo=TRUE}
# Extract PCA (Optional)
df <- as.data.frame(reducedDim(splat.sim)[, c(1:2)])
df$Step <- splat.sim@colData$Step
df$Group <- splat.sim@colData$Group

# Plot the data
ggplot(
  df,
  aes(x = PC1, y = PC2, color = Step, shape = Group)
) +
  geom_point() +
  theme_minimal()
```

If you are interested in learning how this data is simulated and what information
it contains, you can try `?splat.sim` in the R console to read about the details.

## Step 2: Convert to scMaSigPro Object
`scMaSigPro` offers various options to directly convert widely used single-cell
related S4 objects directly to the scmpClass class (now referred to as `scmpObject`),
such as `SingleCellExperiment` or `Monocle3`'s `cell_data_set` class. Here, using the
simulated object (from the `SingleCellExperiment` class) that we have just loaded
into the R environment, we will demonstrate the direct conversion to 
`scmpObject` object.

In our case, we already have pseudotime and path information stored in the
colData slot of the `splat.sim`. The Step column holds the information for the
simulated steps of the paths, which we can treat as a pseudotime variable, and
the Group column has information regarding lineage, i.e., to which path the cell
belongs. We can view this information by executing 
`View(as.data.frame(splat.sim@colData)).`

```{r, eval=TRUE, echo = FALSE}
print(head(as.data.frame(splat.sim@colData), 5))
```

We use `as_scmp()` from `scMaSigPro` and direct it to use the columns present in
the dataset as the columns for `Step` and `Group`. To do this, we have to enable
the parameter `labels_exist` and then pass the existing column names as a named list.

```{r, eval=TRUE, echo=TRUE}
# Helper Function to convert annotated SCE object to scmpObject
scmp.ob <- as_scmp(
  object = splat.sim, from = "sce",
  align_pseudotime = FALSE,
  verbose = TRUE,
  additional_params = list(
    labels_exist = TRUE,
    existing_pseudotime_colname = "Step",
    existing_path_colname = "Group"
  )
)
```

Once the object is created, we can type the name of the object in the R console
to view various attributes, such as the dimensions (number of cells and number
of genes), the available branching paths, and the range of pseudotime.

```{r, eval=TRUE, echo = FALSE}
scmp.ob
```

## Step 3: Pseudo-bulking along the continuum with `squeeze()`

scMaSigPro provides a comprehensive function for pseudo-bulking along the
pseudotime continuum, named squeeze(). This function discretizes a continuous
pseudotime column into bins of equal size using histogram binning methods. The
squeeze() function includes various parameters that can be tailored depending on
the characteristics of the data. Here, we will show the basic usage with the
default parameters:

```{r, eval=TRUE, echo=TRUE}
scmp.ob <- squeeze(scmp.ob)
```

The console output of scMaSigPro is dynamic and displays more attributes as the analysis progresses. To view the results of the binning procedure, we can simply type the object's name into the console:

```{r, eval=TRUE, echo = FALSE}
scmp.ob
```
Here, we observe that the original pseudotime, which ranged from 1 to 100 with
two cells at each step and different paths, is now rescaled to a range of 1 to 8,
with each path having an equal number of bins (8 in total). We also see the average
bin sizes per path, indicating the average number of cells that make up a single
bin for each path.

### Step 3.1: Visualize bins

We can also visually inspect the binning process using a tile plot:

```{r, eval=TRUE, echo=TRUE}
sc.plot.bins.tile(scmp.ob)
```

The tile plot provides a clear view of the number of cells in each bin and how the
sizes of bins compare with those of other paths in the same scmp_binned_pseudotime.

## Step 4: Setting up the Polynomial Model

`scMaSigPro`, being the successor of maSigPro, utilizes the same polynomial
regression model. Let's consider a case with two branching paths along the same
pseudotime scale, modeled with a quadratic polynomial. The model can be represented
as follows:

```{r, echo=FALSE}
library(knitr)
knitr::asis_output("
\\begin{align*}
Y_{i} &\\sim \\text{NegativeBinomial}(\\mu_{i}, \\theta = 10) \\\\
\\log(\\mu_{i}) &= \\beta_{0} + \\beta_{1} \\cdot (\\text{Path}_{B}\\text{vsPath}_{A})_{i} + \\beta_{2} \\cdot T_{\\text{Pseudotime}}^{\\text{Binned}_{i}} \\\\
&\\quad + \\beta_{3} \\cdot (T_{\\text{Pseudotime}}^{\\text{Binned}_{i}} \\cdot \\text{Path}_{B_{i}})  + \\beta_{4} \\cdot (T_{\\text{Pseudotime}}^{\\text{Binned}_{i}})^2 \\\\
&\\quad + \\beta_{5} \\cdot ((T_{\\text{Pseudotime}}^{\\text{Binned}_{i}})^2 \\cdot \\text{Path}_{B_{i}}) + \\text{Offset}_{i} + \\omega_{i} \\cdot \\epsilon_{i}\\\\
\\end{align*}
")
```

To construct this model, we use `sc.make.design.matrix()` to include quadratic terms:

```{r, eval=TRUE, echo=TRUE}
# Polynomial Degree 2
scmp.ob <- sc.make.design.matrix(scmp.ob, poly_degree = 2)
```

### Step 4.1: Visualize the model

Once the model is stored, we can visualize the corresponding polynomial using the `showPoly()` function:

```{r, eval=TRUE, echo=TRUE}
showPoly(scmp.ob)
```

Similarly, we can fit a cubic polynomial by setting the polynomial degree to 3:

```{r, eval=TRUE, echo=TRUE}
# Polynomial Degree 3
scmp.ob <- sc.make.design.matrix(scmp.ob, poly_degree = 3)
showPoly(scmp.ob)
```

However, for simplicity in this tutorial, we will explore a polynomial of degree 1.
Note that increasing the polynomial degree enhances `scMaSigPro`'s performance in
capturing exponential and nonlinear gene expression patterns:

```{r, eval=TRUE, echo=TRUE}
# Polynomial Degree 3
scmp.ob <- sc.make.design.matrix(scmp.ob, poly_degree = 1)
showPoly(scmp.ob)
```

In the above model we have:

* _beta0_: Accounts for differences in expression from the start to the end.

* _beta1*Path1vsPath2_: Captures differences between the branching paths, assuming path A does not change along pseudotime.
    
* _beta2*scmp_binned_pseudotime_: Reflects differences across pseudotime.

* _beta3*scmp_binned_pseudotimexPath1_: Represents interaction between pseudotime and path differences.

## Step 5: Detecting Genes with Non-Flat Profiles

To identify genes that demonstrate significant changes along the binned pseudotime, we use the sc.p.vector() function. This function, adapted from the original maSigPro, includes additional parameters such as the use of offsets and weights.

scMaSigPro expects raw counts as input because it models data using a negative binomial distribution, a count distribution, so the counts should not be normalized to continuous values. To account for library size differences, it uses offsets, which are the log of size factors, similar to DESeq2.

For those who prefer to supply continuous data normalized using methods like log(1+x), the distribution can be changed during model fitting. The weight parameter accounts for variation in bin sizes, enabling uniform modeling of small and large bins.

We can execute sc.p.vector() as follows:

```{r, eval=TRUE, echo=TRUE}
# Detect non-flat profiles
scmp.ob <- sc.p.vector(scmp.ob,
  offset = TRUE, Q = 0.05,
  useWeights = TRUE, logOffset = TRUE, verbose = FALSE
)
scmp.ob
```

The console output reveals that scMaSigPro detected 51 genes with non-flat profiles.

## Step 6: Model Refinement

Having identified genes with significant profiles, we can refine their polynomial
models using sc.T.fit. This function evaluates each term of the polynomial model.
In our case, it will assess which among "beta0 + beta1\*Path1vsPath2 + 
beta2\*scmp_binned_pseudotime + beta3*scmp_binned_pseudotimexPath1" 
significantly contributes to the differences. To execute sc.T.fit, we proceed as follows:

```{r, eval=TRUE, echo=TRUE}
# Model refinement
scmp.ob <- sc.T.fit(scmp.ob, verbose = FALSE)
scmp.ob
```

## Step 7: Selection of Genes

With our refined models in hand, we now focus on identifying genes showing significant differences with pseudotime, among paths, or both. For this purpose, we use the sc.get.siggenes() function. Our aim is to select models with a relatively high $R^2$, indicating simple linear relationships. The vars parameter in sc.get.siggenes() allows us to extract different sets of significant genes. Setting vars = 'all' retrieves all non-flat profiles identified in sc.p.vector with $R^2>=$ the specified threshold. The option vars = 'group' fetches genes per path, resulting in two gene lists that demonstrate associative significance among paths, helping us identify genes associated with one path or the other. The vars = 'each' option finds significance for each term in the polynomial. In our case, we are interested in genes differentially expressed between paths and over time, so we will choose vars = 'group'.
```{r}
scmp.ob <- sc.get.siggenes(
  scmpObj = scmp.ob,
  rsq = 0.7,
  vars = "groups",
  significant.intercept = "dummy",
  includeInflu = T
)
```

By setting the vars parameter to "groups", the function will add genes with $R^2$ >= 0.7 to the object. To explore the number of genes per group, we can use an upset plot:
```{r}
sc.path.intersection(scmp.ob)
```

Here we see that 

```{r}
a <- sc.PlotGroups(scmp.ob, "Gene9", logs = T, logType = "log")
b <- sc.PlotGroups(scmp.ob, "Gene95", logs = T, logType = "log")
c <- sc.PlotGroups(scmp.ob, "Gene10", logs = T, logType = "log")
d <- sc.PlotGroups(scmp.ob, "Gene92", logs = T, logType = "log")
ggpubr::ggarrange(a, b, c, d, nrow = 2, ncol = 2)
```


## Session Info
```{r}
sessionInfo(package = "scMaSigPro")
```
