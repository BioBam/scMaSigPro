#' Detection of genes with Isoforms with different gene expression in time course experiments
#'
#' \code{IsoModel} Performs a model comparison for each gene to detect genes with different trends in time course experiments and applies maSigPro to the Isoforms belonging to selected genes.
#'
#' @title Detection of genes with Isoforms with different gene expression in time course experiments
#'
#' @description
#' \code{IsoModel} Performs a model comparison for each gene to detect genes with different trends in time course experiments and applies maSigPro to the Isoforms belonging to selected genes.
#'
#' @usage
#' IsoModel(data, gen, design = NULL, Q = 0.05, min.obs = 6, minorFoldfilter = NULL,
#'     counts = FALSE, family = NULL, theta = 10, epsilon = 1e-05)
#'
#' @arguments
#' \item{data}{matrix containing isoform expression. Isoforms must be in rows and experimental conditions in columns}
#' \item{gen}{vector with the name of the gene each isoform belongs to}
#' \item{design}{design matrix for the regression fit such as that generated by the \code{\link{make.design.matrix}} function}
#' \item{Q}{significance level}
#' \item{min.obs}{cases with less than this number of true numerical values will be excluded from the analysis. Minimum value to estimate the model is (degree+1)xGroups+1. Default is  6.  }
#' \item{minorFoldfilter}{fold expression difference between minor isoforms and the most expressed isoform to exclude minor isoforms from analysis. Default NULL }
#' \item{counts}{a logical indicating whether your data are counts}
#' \item{family}{the distribution function to be used in the glm model. It must be specified as a function: gaussian(), poisson(), negative.binomial(theta)...
#'     If NULL family will be negative.binomial(theta) when counts=TRUE or gaussian() when counts=FALSE }
#' \item{theta}{theta parameter for negative.binomial family}
#' \item{epsilon}{argument to pass to \code{glm.control}, convergence tolerance in the iterative process to estimate de glm model}
#'
#' @details
#' \code{rownames(design)} and \code{colnames(data)} must be identical vectors and indicate experimental condition names.
#'
#' \code{rownames(data)} should contain unique isoform IDs.
#'
#' \code{colnames(design)} are the given names for the variables in the regression model.
#'
#' @value
#' \item{data}{input data matrix to be used in the following steps}
#' \item{gen}{input gen vector to be used in the following steps}
#' \item{design}{input design matrix to be used in the following steps}
#' \item{DSG}{Names of the selected genes: Differentially Spliced Genes}
#' \item{pvector}{p.vector output of isoforms that belong to selected.genes}
#' \item{Tfit}{Tfit output of isoforms that belong to selected.genes}
#'
#' @references
#' \item{Nueda, M.J., Martorell, J., Marti, C., Tarazona, S., Conesa, A. 2018. Identification and visualization of differential isoform expression in RNA-seq time series. Bioinformatics. 34, 3, 524-526.}
#' \item{Nueda, M.J., Tarazona, S., Conesa, A. 2014. Next maSigPro: updating maSigPro bioconductor package for RNA-seq time series. Bioinformatics, 30, 2598-602.}
#' \item{Conesa, A., Nueda M.J., Ferrer, A., Talon, T. 2006. maSigPro: a Method to Identify Significant Differential Expression Profiles in Time-Course Microarray Experiments. Bioinformatics 22, 1096-1102.}
#'
#' @author Maria Jose Nueda, \email{mj.nueda@ua.es}
#'
#' @seealso \code{\link{p.vector}}, \code{\link{T.fit}}
#'
#' @examples
#' data(ISOdata)
#' data(ISOdesign)
#' mdis <- make.design.matrix(ISOdesign)
#' MyIso <- IsoModel(data = ISOdata[, -1], gen = ISOdata[, 1], design = mdis, counts = TRUE)
#' Myget <- getDS(MyIso)
#' see <- seeDS(Myget, cluster.all = FALSE, k = 6)
#' table <- tableDS(see)
#' table$IsoTable
IsoModel <- function(data, gen, design = NULL, Q = 0.05, min.obs = 6, minorFoldfilter = NULL,
                     counts = FALSE, family = NULL, theta = 10, epsilon = 1e-05) {
  #---------------------------------------------------------------------------------------------------
  # Step 1: Extract unique genes and calculate the number of unique genes (g)
  #---------------------------------------------------------------------------------------------------
  Genes <- unique(gen)
  g <- length(Genes)

  #---------------------------------------------------------------------------------------------------
  # Step 2: Set the default family if not provided
  #---------------------------------------------------------------------------------------------------
  if (is.null(family)) {
    if (!counts) {
      family <- gaussian()
    }
    if (counts) {
      family <- negative.binomial(theta)
    }
  }

  #---------------------------------------------------------------------------------------------------
  # STEP -1: Remove cases with low expressed isoforms:
  #---------------------------------------------------------------------------------------------------
  print(paste(nrow(data), "transcripts"))
  print(paste(length(unique(gen)), "genes"))

  if (!is.null(minorFoldfilter)) {
    # If minorFoldfilter is provided, remove low expressed minor isoforms
    print("Removing low expressed minor isoforms")
    moreOne <- names(which(table(gen) > 1))
    iso.sel <- NULL
    gene.sel <- NULL
    for (i in moreOne) {
      # For each gene with more than one isoform:
      which(gen == i)
      gene.data <- data[which(gen == i), ]
      isoSUM <- apply(gene.data, 1, sum)
      major <- names(which(isoSUM == max(isoSUM)))[1]
      minors <- names(which(isoSUM != max(isoSUM)))
      div <- as.numeric(matrix(rep(gene.data[major, ], length(minors)), ncol = ncol(data), length(minors), byrow = T)) / as.matrix(gene.data[minors, ])
      is <- names(which(apply(div, 1, min, na.rm = T) < minorFoldfilter))
      iso.sel <- c(iso.sel, is)
      gene.sel <- c(gene.sel, rep(i, length(is)))
    }
    data <- data[iso.sel, ]
    gen <- gene.sel
    print(dim(data))
    print(length(gen))
    print("Done")
    print(paste(nrow(data), "remaining transcripts"))
    print(paste(length(unique(gen)), "remaining genes"))
  }

  #---------------------------------------------------------------------------------------------------
  #  STEP 0: Remove cases with 1 transcript:
  #---------------------------------------------------------------------------------------------------
  NT <- tapply(rownames(data), gen, length)
  Genes1 <- names(which(NT != 1))
  data1 <- data[gen %in% Genes1, ]
  gen1 <- gen[gen %in% Genes1]
  Genes1 <- unique(gen1)
  g <- length(Genes1)
  dis <- as.data.frame(design$dis)
  mycolnames <- colnames(dis)

  #---------------------------------------------------------------------------------------------------
  # STEP 1: Gene models comparison.
  #---------------------------------------------------------------------------------------------------
  pval <- NULL

  for (i in 1:g) {
    # For each gene:
    div <- c(1:round(g / 100)) * 100
    if (is.element(i, div)) {
      print(paste(c("fitting gene", i, "out of", g), collapse = " "))
    }

    zz <- data1[gen1 == Genes1[i], ]
    nt <- nrow(zz)

    dis.gen <- REP(dis, nt)
    y <- c(t(as.matrix(zz)))
    transcript <- factor(rep(c(1:nt), each = ncol(zz)))
    ydis <- cbind(y, dis.gen, transcript)

    model0 <- glm(Formula0(mycolnames), data = ydis, family = family, epsilon = epsilon)
    model1 <- glm(Formula1(mycolnames), data = ydis, family = family, epsilon = epsilon)

    if (family$family == "gaussian") {
      pvali <- anova(model0, model1, test = "F")[2, 6]
    } else {
      pvali <- anova(model0, model1, test = "Chisq")[2, 5]
    }
    names(pvali) <- Genes1[i]
    pval <- c(pval, pvali)
  }
  num.genes <- sum(p.adjust(pval) < Q, na.rm = TRUE)
  selected.genes <- names(sort(p.adjust(pval))[1:num.genes])

  #---------------------------------------------------------------------------------------------------
  # STEP 2: p.vector and T.fit to the transcripts that belong to selected.genes
  #---------------------------------------------------------------------------------------------------
  data2 <- data[gen %in% selected.genes, ]
  gen2 <- gen[gen %in% selected.genes]
  pvector2 <- p.vector(data2, design, counts = counts, item = "isoform")
  Tfit2 <- T.fit(pvector2, item = "isoform")

  #---------------------------------------------------------------------------------------------------
  # Output
  #---------------------------------------------------------------------------------------------------
  ISO.SOL <- list(data, gen, design, selected.genes, pvector2, Tfit2)
  names(ISO.SOL) <- c("data", "gen", "design", "DSG", "pvector", "Tfit")
  return(ISO.SOL)
}


#---------------------------------------------------------------------------------------------------
# Auxiliar internal functions: REP, Formula0, Formula1
#---------------------------------------------------------------------------------------------------

REP <- function(D, k) {
  r <- nrow(D)
  c <- ncol(D)
  DD <- NULL
  for (i in 1:c) {
    DDi <- rep(D[, i], k)
    DD <- cbind(DD, DDi)
  }
  colnames(DD) <- colnames(D)
  as.data.frame(DD)
}

#---------------------------------------------------------------------------

Formula0 <- function(names) {
  formula <- "y~"

  if (length(names) == 1) {
    formula <- paste(formula, names[1], "+ transcript")
  } else if (length(names) > 1) {
    for (i in 1:(length(names))) {
      formula <- paste(formula, names[i], "+")
    }
    formula <- paste(formula, "transcript")
  }
  formula <- as.formula(formula)
  formula
}

#---------------------------------------------------------------------------

Formula1 <- function(names) {
  formula <- "y~"

  if (length(names) == 1) {
    formula <- paste(formula, names[1], "* transcript")
  } else if (length(names) > 1) {
    formula <- paste(formula, "(")
    for (i in 1:(length(names) - 1)) {
      formula <- paste(formula, names[i], "+")
    }
    formula <- paste(formula, names[length(names)])
    formula <- paste(formula, ") * transcript")
  }
  formula <- as.formula(formula)
  formula
}
